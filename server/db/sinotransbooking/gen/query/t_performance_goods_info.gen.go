// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/dk-sirius/scaf-fold-demo/server/db/sinotransbooking/gen/model"
)

func newPerformanceGoods(db *gorm.DB, opts ...gen.DOOption) performanceGoods {
	_performanceGoods := performanceGoods{}

	_performanceGoods.performanceGoodsDo.UseDB(db, opts...)
	_performanceGoods.performanceGoodsDo.UseModel(&model.PerformanceGoods{})

	tableName := _performanceGoods.performanceGoodsDo.TableName()
	_performanceGoods.ALL = field.NewAsterisk(tableName)
	_performanceGoods.FID = field.NewInt64(tableName, "f_id")
	_performanceGoods.FCreatedAt = field.NewTime(tableName, "f_created_at")
	_performanceGoods.FUpdatedAt = field.NewTime(tableName, "f_updated_at")
	_performanceGoods.FDeletedAt = field.NewTime(tableName, "f_deleted_at")
	_performanceGoods.FDeleted = field.NewInt16(tableName, "f_deleted")
	_performanceGoods.FPerformanceID = field.NewInt64(tableName, "f_performance_id")
	_performanceGoods.FAddressForNotifier = field.NewString(tableName, "f_address_for_notifier")
	_performanceGoods.FAddressForReceiver = field.NewString(tableName, "f_address_for_receiver")
	_performanceGoods.FAddressForSender = field.NewString(tableName, "f_address_for_sender")
	_performanceGoods.FContactForNotifier = field.NewString(tableName, "f_contact_for_notifier")
	_performanceGoods.FContactForReceiver = field.NewString(tableName, "f_contact_for_receiver")
	_performanceGoods.FContactForSender = field.NewString(tableName, "f_contact_for_sender")
	_performanceGoods.FEnglishDesc = field.NewString(tableName, "f_english_desc")
	_performanceGoods.FAddressForNotifierSec = field.NewString(tableName, "f_address_for_notifier_sec")
	_performanceGoods.FNameForNotifierSec = field.NewString(tableName, "f_name_for_notifier_sec")
	_performanceGoods.FGoodsRemark = field.NewString(tableName, "f_goods_remark")
	_performanceGoods.FGrossWeight = field.NewString(tableName, "f_gross_weight")
	_performanceGoods.FMeasurement = field.NewString(tableName, "f_measurement")
	_performanceGoods.FNameForNotifier = field.NewString(tableName, "f_name_for_notifier")
	_performanceGoods.FNameForReceiver = field.NewString(tableName, "f_name_for_receiver")
	_performanceGoods.FNameForSender = field.NewString(tableName, "f_name_for_sender")
	_performanceGoods.FNumberOf = field.NewString(tableName, "f_number_of")
	_performanceGoods.FPackageUnit = field.NewString(tableName, "f_package_unit")
	_performanceGoods.FStockUptime = field.NewTime(tableName, "f_stock_uptime")
	_performanceGoods.FBillType = field.NewInt32(tableName, "f_bill_type")
	_performanceGoods.FTransportMode = field.NewInt32(tableName, "f_transport_mode")
	_performanceGoods.FPaymentMode = field.NewInt32(tableName, "f_payment_mode")
	_performanceGoods.FBilNumber = field.NewString(tableName, "f_bil_number")
	_performanceGoods.FReleaseType = field.NewInt32(tableName, "f_release_type")

	_performanceGoods.fillFieldMap()

	return _performanceGoods
}

type performanceGoods struct {
	performanceGoodsDo performanceGoodsDo

	ALL                    field.Asterisk
	FID                    field.Int64
	FCreatedAt             field.Time
	FUpdatedAt             field.Time
	FDeletedAt             field.Time
	FDeleted               field.Int16
	FPerformanceID         field.Int64
	FAddressForNotifier    field.String
	FAddressForReceiver    field.String
	FAddressForSender      field.String
	FContactForNotifier    field.String
	FContactForReceiver    field.String
	FContactForSender      field.String
	FEnglishDesc           field.String
	FAddressForNotifierSec field.String
	FNameForNotifierSec    field.String
	FGoodsRemark           field.String
	FGrossWeight           field.String
	FMeasurement           field.String
	FNameForNotifier       field.String
	FNameForReceiver       field.String
	FNameForSender         field.String
	FNumberOf              field.String
	FPackageUnit           field.String
	FStockUptime           field.Time
	FBillType              field.Int32
	FTransportMode         field.Int32
	FPaymentMode           field.Int32
	FBilNumber             field.String
	FReleaseType           field.Int32

	fieldMap map[string]field.Expr
}

func (p performanceGoods) Table(newTableName string) *performanceGoods {
	p.performanceGoodsDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p performanceGoods) As(alias string) *performanceGoods {
	p.performanceGoodsDo.DO = *(p.performanceGoodsDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *performanceGoods) updateTableName(table string) *performanceGoods {
	p.ALL = field.NewAsterisk(table)
	p.FID = field.NewInt64(table, "f_id")
	p.FCreatedAt = field.NewTime(table, "f_created_at")
	p.FUpdatedAt = field.NewTime(table, "f_updated_at")
	p.FDeletedAt = field.NewTime(table, "f_deleted_at")
	p.FDeleted = field.NewInt16(table, "f_deleted")
	p.FPerformanceID = field.NewInt64(table, "f_performance_id")
	p.FAddressForNotifier = field.NewString(table, "f_address_for_notifier")
	p.FAddressForReceiver = field.NewString(table, "f_address_for_receiver")
	p.FAddressForSender = field.NewString(table, "f_address_for_sender")
	p.FContactForNotifier = field.NewString(table, "f_contact_for_notifier")
	p.FContactForReceiver = field.NewString(table, "f_contact_for_receiver")
	p.FContactForSender = field.NewString(table, "f_contact_for_sender")
	p.FEnglishDesc = field.NewString(table, "f_english_desc")
	p.FAddressForNotifierSec = field.NewString(table, "f_address_for_notifier_sec")
	p.FNameForNotifierSec = field.NewString(table, "f_name_for_notifier_sec")
	p.FGoodsRemark = field.NewString(table, "f_goods_remark")
	p.FGrossWeight = field.NewString(table, "f_gross_weight")
	p.FMeasurement = field.NewString(table, "f_measurement")
	p.FNameForNotifier = field.NewString(table, "f_name_for_notifier")
	p.FNameForReceiver = field.NewString(table, "f_name_for_receiver")
	p.FNameForSender = field.NewString(table, "f_name_for_sender")
	p.FNumberOf = field.NewString(table, "f_number_of")
	p.FPackageUnit = field.NewString(table, "f_package_unit")
	p.FStockUptime = field.NewTime(table, "f_stock_uptime")
	p.FBillType = field.NewInt32(table, "f_bill_type")
	p.FTransportMode = field.NewInt32(table, "f_transport_mode")
	p.FPaymentMode = field.NewInt32(table, "f_payment_mode")
	p.FBilNumber = field.NewString(table, "f_bil_number")
	p.FReleaseType = field.NewInt32(table, "f_release_type")

	p.fillFieldMap()

	return p
}

func (p *performanceGoods) WithContext(ctx context.Context) *performanceGoodsDo {
	return p.performanceGoodsDo.WithContext(ctx)
}

func (p performanceGoods) TableName() string { return p.performanceGoodsDo.TableName() }

func (p performanceGoods) Alias() string { return p.performanceGoodsDo.Alias() }

func (p *performanceGoods) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *performanceGoods) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 29)
	p.fieldMap["f_id"] = p.FID
	p.fieldMap["f_created_at"] = p.FCreatedAt
	p.fieldMap["f_updated_at"] = p.FUpdatedAt
	p.fieldMap["f_deleted_at"] = p.FDeletedAt
	p.fieldMap["f_deleted"] = p.FDeleted
	p.fieldMap["f_performance_id"] = p.FPerformanceID
	p.fieldMap["f_address_for_notifier"] = p.FAddressForNotifier
	p.fieldMap["f_address_for_receiver"] = p.FAddressForReceiver
	p.fieldMap["f_address_for_sender"] = p.FAddressForSender
	p.fieldMap["f_contact_for_notifier"] = p.FContactForNotifier
	p.fieldMap["f_contact_for_receiver"] = p.FContactForReceiver
	p.fieldMap["f_contact_for_sender"] = p.FContactForSender
	p.fieldMap["f_english_desc"] = p.FEnglishDesc
	p.fieldMap["f_address_for_notifier_sec"] = p.FAddressForNotifierSec
	p.fieldMap["f_name_for_notifier_sec"] = p.FNameForNotifierSec
	p.fieldMap["f_goods_remark"] = p.FGoodsRemark
	p.fieldMap["f_gross_weight"] = p.FGrossWeight
	p.fieldMap["f_measurement"] = p.FMeasurement
	p.fieldMap["f_name_for_notifier"] = p.FNameForNotifier
	p.fieldMap["f_name_for_receiver"] = p.FNameForReceiver
	p.fieldMap["f_name_for_sender"] = p.FNameForSender
	p.fieldMap["f_number_of"] = p.FNumberOf
	p.fieldMap["f_package_unit"] = p.FPackageUnit
	p.fieldMap["f_stock_uptime"] = p.FStockUptime
	p.fieldMap["f_bill_type"] = p.FBillType
	p.fieldMap["f_transport_mode"] = p.FTransportMode
	p.fieldMap["f_payment_mode"] = p.FPaymentMode
	p.fieldMap["f_bil_number"] = p.FBilNumber
	p.fieldMap["f_release_type"] = p.FReleaseType
}

func (p performanceGoods) clone(db *gorm.DB) performanceGoods {
	p.performanceGoodsDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p performanceGoods) replaceDB(db *gorm.DB) performanceGoods {
	p.performanceGoodsDo.ReplaceDB(db)
	return p
}

type performanceGoodsDo struct{ gen.DO }

func (p performanceGoodsDo) Debug() *performanceGoodsDo {
	return p.withDO(p.DO.Debug())
}

func (p performanceGoodsDo) WithContext(ctx context.Context) *performanceGoodsDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p performanceGoodsDo) ReadDB() *performanceGoodsDo {
	return p.Clauses(dbresolver.Read)
}

func (p performanceGoodsDo) WriteDB() *performanceGoodsDo {
	return p.Clauses(dbresolver.Write)
}

func (p performanceGoodsDo) Session(config *gorm.Session) *performanceGoodsDo {
	return p.withDO(p.DO.Session(config))
}

func (p performanceGoodsDo) Clauses(conds ...clause.Expression) *performanceGoodsDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p performanceGoodsDo) Returning(value interface{}, columns ...string) *performanceGoodsDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p performanceGoodsDo) Not(conds ...gen.Condition) *performanceGoodsDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p performanceGoodsDo) Or(conds ...gen.Condition) *performanceGoodsDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p performanceGoodsDo) Select(conds ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p performanceGoodsDo) Where(conds ...gen.Condition) *performanceGoodsDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p performanceGoodsDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *performanceGoodsDo {
	return p.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (p performanceGoodsDo) Order(conds ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p performanceGoodsDo) Distinct(cols ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p performanceGoodsDo) Omit(cols ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p performanceGoodsDo) Join(table schema.Tabler, on ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p performanceGoodsDo) LeftJoin(table schema.Tabler, on ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p performanceGoodsDo) RightJoin(table schema.Tabler, on ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p performanceGoodsDo) Group(cols ...field.Expr) *performanceGoodsDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p performanceGoodsDo) Having(conds ...gen.Condition) *performanceGoodsDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p performanceGoodsDo) Limit(limit int) *performanceGoodsDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p performanceGoodsDo) Offset(offset int) *performanceGoodsDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p performanceGoodsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *performanceGoodsDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p performanceGoodsDo) Unscoped() *performanceGoodsDo {
	return p.withDO(p.DO.Unscoped())
}

func (p performanceGoodsDo) Create(values ...*model.PerformanceGoods) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p performanceGoodsDo) CreateInBatches(values []*model.PerformanceGoods, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p performanceGoodsDo) Save(values ...*model.PerformanceGoods) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p performanceGoodsDo) First() (*model.PerformanceGoods, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PerformanceGoods), nil
	}
}

func (p performanceGoodsDo) Take() (*model.PerformanceGoods, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PerformanceGoods), nil
	}
}

func (p performanceGoodsDo) Last() (*model.PerformanceGoods, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PerformanceGoods), nil
	}
}

func (p performanceGoodsDo) Find() ([]*model.PerformanceGoods, error) {
	result, err := p.DO.Find()
	return result.([]*model.PerformanceGoods), err
}

func (p performanceGoodsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PerformanceGoods, err error) {
	buf := make([]*model.PerformanceGoods, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p performanceGoodsDo) FindInBatches(result *[]*model.PerformanceGoods, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p performanceGoodsDo) Attrs(attrs ...field.AssignExpr) *performanceGoodsDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p performanceGoodsDo) Assign(attrs ...field.AssignExpr) *performanceGoodsDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p performanceGoodsDo) Joins(fields ...field.RelationField) *performanceGoodsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p performanceGoodsDo) Preload(fields ...field.RelationField) *performanceGoodsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p performanceGoodsDo) FirstOrInit() (*model.PerformanceGoods, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PerformanceGoods), nil
	}
}

func (p performanceGoodsDo) FirstOrCreate() (*model.PerformanceGoods, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PerformanceGoods), nil
	}
}

func (p performanceGoodsDo) FindByPage(offset int, limit int) (result []*model.PerformanceGoods, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p performanceGoodsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p performanceGoodsDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p performanceGoodsDo) Delete(models ...*model.PerformanceGoods) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *performanceGoodsDo) withDO(do gen.Dao) *performanceGoodsDo {
	p.DO = *do.(*gen.DO)
	return p
}
